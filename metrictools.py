import pandas as pd
import matplotlib.pyplot as plt
from ultralytics import YOLO
import cv2

def plot_yolo_metrics(results_csv_path):
    """
    Plot training and validation metrics from a YOLOv8 results file.

    Parameters:
        results_csv_path (str): Path to the 'results.csv' file generated by YOLOv8 training.
    """
    try:
        # Load the data
        data = pd.read_csv(results_csv_path)

        # Extract metrics
        epochs = data['epoch']
        
        # Calculate total losses for training and validation
        train_loss = data['train/box_loss'] + data['train/cls_loss'] + data['train/dfl_loss']
        val_loss = data['val/box_loss'] + data['val/cls_loss'] + data['val/dfl_loss']
        
        # Extract accuracy metrics
        precision = data['metrics/precision(B)']
        recall = data['metrics/recall(B)']
        mAP50 = data['metrics/mAP50(B)']
        mAP50_95 = data['metrics/mAP50-95(B)']

        # Plot the data
        plt.figure(figsize=(14, 8))

        # Plot losses
        plt.subplot(2, 1, 1)
        plt.plot(epochs, train_loss, label='Training Loss', color='blue')
        plt.plot(epochs, val_loss, label='Validation Loss', color='orange', linestyle='--')
        plt.xlabel('Epochs')
        plt.ylabel('Loss')
        plt.title('Training and Validation Loss')
        plt.legend()

        # Plot accuracy metrics
        plt.subplot(2, 1, 2)
        plt.plot(epochs, precision, label='Precision', color='green')
        plt.plot(epochs, recall, label='Recall', color='red')
        plt.plot(epochs, mAP50, label='mAP@50', color='purple')
        plt.plot(epochs, mAP50_95, label='mAP@50-95', color='brown')
        plt.xlabel('Epochs')
        plt.ylabel('Metrics')
        plt.title('Validation Metrics')
        plt.legend()

        plt.tight_layout()
        plt.show()

    except FileNotFoundError:
        print(f"File not found: {results_csv_path}")
    except KeyError as e:
        print(f"Missing column in results file: {e}")
    except Exception as e:
        print(f"An error occurred: {e}")



def display_results(results):
    """
    Displays the results of the object detection model.

    Parameters:
        results (list): A list of result objects (e.g., from a model inference) that contain `boxes` and methods like `show()` and `plot()`.
    
    Returns:
        None
    """

    plt.figure(figsize=(10, 10))
    # Display results with bounding boxes
    for result in results:
        boxes = result.boxes  # Assuming `result.boxes` contains the detected boxes
        plt.imshow(result.plot())  # Assuming `result.plot()` returns an image with drawn boxes
        plt.axis("off")  # Hide axes
        plt.show()  # Display the plot

    return



def display_predictions_side_by_side(model_path, test_folder, num_images_to_show=5, imgsz=640, device=0):
    """
    Displays original and predicted images side by side for easy comparison.

    Args:
        model_path (str): Path to the trained YOLO model file (e.g., "path_to_model.pt").
        test_folder (str): Path to the folder containing test images.
        num_images_to_show (int): Number of images to display (default is 5).
        imgsz (int): Image size to resize during inference (default is 640).
        device (int or str): Device to use for inference (e.g., 0 for GPU, 'cpu' for CPU).
    """
    # Load the trained YOLO model
    model = YOLO(model_path)

    # Run inference on the test folder
    results = model.predict(
        source=test_folder,  # Test folder containing images
        save=False,  # Do not save predictions to disk
        imgsz=imgsz,  # Resize images for inference
        device=device,  # Use GPU (0) or CPU ('cpu')
        verbose=False
    )

    # Display the images
    for idx, result in enumerate(results[:num_images_to_show]):
        # Load the original image
        original_image = cv2.imread(result.path)  # Read the original image
        original_image = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB

        # Get the predicted image
        predicted_image = result.plot()  # Generate the predicted image with annotations

        # Create a side-by-side plot
        plt.figure(figsize=(12, 6))
        plt.subplot(1, 2, 1)
        plt.imshow(original_image)
        plt.axis("off")
        plt.title("Original Image")

        plt.subplot(1, 2, 2)
        plt.imshow(predicted_image)
        plt.axis("off")
        plt.title("Predicted Image")

        plt.suptitle(f"Image {idx+1}", fontsize=16)
        plt.show()

